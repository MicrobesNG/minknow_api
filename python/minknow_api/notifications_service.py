### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
import minknow_api
from minknow_api.notifications_pb2_grpc import *
import minknow_api.notifications_pb2 as notifications_pb2
from minknow_api.notifications_pb2 import *
from minknow_api._support import MessageWrapper, ArgumentError
import time
import logging
import sys

__all__ = [
    "NotificationsService",
    "NotificationContent",
    "Notification",
    "StreamNotificationsRequest",
    "StreamNotificationsResponse",
    "MarkNotificationsAsReadRequest",
    "MarkNotificationsAsReadResponse",
    "CreateNotificationRequest",
    "CreateNotificationResponse",
]

def run_with_retry(method, message, timeout, unwraps, full_name):
    retry_count = 20
    error = None
    for i in range(retry_count):
        try:
            result = MessageWrapper(method(message, timeout=timeout), unwraps=unwraps)
            return result
        except grpc.RpcError as e:
            # Retrying unidentified grpc errors to keep clients from crashing
            retryable_error = (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details() or \
                                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()))
            if retryable_error:
                logging.info('Bypassed ({}: {}) error for grpc: {}. Attempt {}.'.format(e.code(), e.details(), full_name, i))
            else:
                raise
            error = e
        time.sleep(1)
    raise error


class NotificationsService(object):
    def __init__(self, channel):
        self._stub = NotificationsServiceStub(channel)
        self._pb = notifications_pb2
    def stream_notifications(self, _message=None, _timeout=None, **kwargs):
        """Sends an initial list of all historical notifications and sends any new notifications as they are
        created or, optionally, updated

        

        Args:
            _message (minknow_api.notifications_pb2.StreamNotificationsRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
                Note that this is the time until the call ends, not the time between returned
                messages.
            include_updates_for_existing (bool, optional): Whether updates to existing notifications (e.g., marking as read) should be included in the stream.
                Defaults to false

        Returns:
            iter of minknow_api.notifications_pb2.StreamNotificationsResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.stream_notifications,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.notifications.NotificationsService")

        unused_args = set(kwargs.keys())

        _message = StreamNotificationsRequest()

        if "include_updates_for_existing" in kwargs:
            unused_args.remove("include_updates_for_existing")
            _message.include_updates_for_existing = kwargs['include_updates_for_existing']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to stream_notifications: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.stream_notifications,
                              _message, _timeout,
                              [],
                              "minknow_api.notifications.NotificationsService")
    def mark_notifications_as_read(self, _message=None, _timeout=None, **kwargs):
        """Mark existing notifications as `read`

        

        Args:
            _message (minknow_api.notifications_pb2.MarkNotificationsAsReadRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            ids (str, optional): A list of IDs for the notifications to mark as read. This will set the `read` attribute
                to `true`. If `read` is already `true` for a specific ID then it is not updated.

        Returns:
            minknow_api.notifications_pb2.MarkNotificationsAsReadResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.mark_notifications_as_read,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.notifications.NotificationsService")

        unused_args = set(kwargs.keys())

        _message = MarkNotificationsAsReadRequest()

        if "ids" in kwargs:
            unused_args.remove("ids")
            _message.ids.extend(kwargs['ids'])

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to mark_notifications_as_read: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.mark_notifications_as_read,
                              _message, _timeout,
                              [],
                              "minknow_api.notifications.NotificationsService")
    def create_notification(self, _message=None, _timeout=None, **kwargs):
        """Create a new notification

        

        Args:
            _message (minknow_api.notifications_pb2.CreateNotificationRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            content (minknow_api.notifications_pb2.NotificationContent, optional): Content to set for a new notification

        Returns:
            minknow_api.notifications_pb2.CreateNotificationResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.create_notification,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.notifications.NotificationsService")

        unused_args = set(kwargs.keys())

        _message = CreateNotificationRequest()

        if "content" in kwargs:
            unused_args.remove("content")
            _message.content.CopyFrom(kwargs['content'])

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to create_notification: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.create_notification,
                              _message, _timeout,
                              [],
                              "minknow_api.notifications.NotificationsService")